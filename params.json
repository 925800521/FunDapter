{"name":"Fundapter","tagline":"Simplify Adapter creation for your Android ListViews.","body":"FunDapter takes the pain and hassle out of creating a new Adapter class for each ListView you have in your Android app.\r\n\r\nIt is a new approach to custom adapter creation for Android apps. \r\nYou get free ViewHolder pattern support, field validation so you don't get bit by trivial bugs and best of all - you get to keep it DRY!\r\n\r\n## What you used to do:\r\n\r\n1. Subclass BaseAdapter or copy existing adapter you already wrote.\r\n2. Create a ViewHolder static class a define all the views in it.\r\n3. Write (Copy.. don't fool yourself!) the whole ViewHolder creation code from somewhere.\r\n4. Write all the \"findViewById\" lines.\r\n5. Start filling data in the views inside the getView method.\r\n\r\nWell that was boring! I feel your pain!\r\n\r\n## What FunDapter lets you do:\r\n\r\n1. Create a new BindDictionary\r\n2. Add fields.\r\n3. Create a new FunDapter instance, supplying the BindDictionary, layout resource file and item list.\r\n\r\n## Getting Started\r\n\r\nThis is the `Product` class we'll create an adapter for:\r\n\r\n\tpublic class Product {\r\n\t\r\n\t\tpublic String title;\r\n\t\tpublic String description;\r\n\t\tpublic String imageUrl;\r\n\t\tpublic double price;\r\n\t}\r\n\r\n### Create a new BindDictionary instance: \r\n\r\n\tBindDictionary<Product> dict = new BindDictionary<Product>();\r\n\r\n### Adding a basic text field:\r\n\r\n\tdict.addStringField(R.id.description,\r\n\t\tnew StringExtractor<Product>() {\r\n\r\n\t\t    @Override\r\n\t\t    public String getStringValue(Product item, int position) {\r\n\t\t\t\treturn item.description;\r\n\t\t    }\r\n\t\t});\r\n\t\t\r\nNotice how you simply provide the id of the `TextView` and an \r\nimplementation of the `StringExtractor` which will be used to get the correct `String` value from your `Product`.\r\n\r\n--------------------\r\n### Now a more complicated text field:\r\n\r\n\tdict.addStringField(R.id.title,\r\n\t\tnew StringExtractor<Product>() {\r\n\r\n\t\t    @Override\r\n\t\t    public String getStringValue(Product item, int position) {\r\n\t\t\t\treturn item.title;\r\n\t\t    }\r\n\t\t}).typeface(myBoldFace).visibilityIfNull(View.GONE);\r\n\r\nNotice how you can chain calls to get some more complex behaviours out of your views. \r\n`typeface()` will set a typeface on the view while \r\n`visibilityIfNull()` will change the visibility of the field according to the value being null or not.\r\n\r\n--------------------\r\n\r\n### What about our image? Lets add that as well:\r\n\r\n\tprodDict.addImageField(R.id.productImage,\r\n\t\tnew StringExtractor<Product>() {\r\n\r\n\t\t    @Override\r\n\t\t    public String getStringValue(Product item, int position) {\r\n\t\t\t\treturn item.imageUrl;\r\n\t\t    }\r\n\t\t}, new ImageLoader() {\r\n\t\t    @Override\r\n\t\t    public void loadImage(String url, ImageView view) {\r\n\t\t\t\t//insert your own async image loader implementation\r\n\t\t    }\r\n\t\t});\r\n\t\t\r\nIn here the `StringExtractor` grabs the URL from the `Product` item while the `ImageLoader` gives you a \r\nreference to the view and the URL you extracted so you can use your own custom lazy image loading implementation.\r\n\r\n-------------\r\n### Finally, create the adapter:\r\n\r\n\tFunDapter<Product> adapter = new FunDapter<Product>(getActivity(), productArrayList,\r\n\t\t\tR.layout.product_list_item, dict);\r\n\r\n","google":"UA-40929159-1","note":"Don't delete this file! It's used internally to help with page regeneration."}